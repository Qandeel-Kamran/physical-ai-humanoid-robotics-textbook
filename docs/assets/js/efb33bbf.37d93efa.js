"use strict";(self.webpackChunkmy_textbook_website=self.webpackChunkmy_textbook_website||[]).push([[972],{6236:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"chapter-15-safety","title":"Safety and Compliance in Physical AI","description":"Understanding safety standards, risk assessment, and compliance requirements for humanoid robots operating in human environments.","source":"@site/docs/chapter-15-safety.md","sourceDirName":".","slug":"/chapter-15-safety","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter-15-safety","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"title":"Safety and Compliance in Physical AI","description":"Understanding safety standards, risk assessment, and compliance requirements for humanoid robots operating in human environments.","sidebar_position":15,"wordCount":"1300-1600","prerequisites":"Safety engineering and risk assessment principles","learningOutcomes":["Implement safety systems that protect humans and robots","Apply safety standards to humanoid robot design","Conduct risk assessments for physical AI systems"],"subtopics":["Safety standards and regulations","Collision avoidance and safe interaction","Emergency stop and fail-safe mechanisms","Risk assessment and mitigation","Human safety in close proximity operations"],"status":"draft","authors":["Textbook Author"],"reviewers":["Domain Expert"]},"sidebar":"textbookSidebar","previous":{"title":"Energy Systems and Power Management","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter-14-energy"},"next":{"title":"Applications and Case Studies","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter-16-applications"}}');var i=t(4848),o=t(8453);const a={title:"Safety and Compliance in Physical AI",description:"Understanding safety standards, risk assessment, and compliance requirements for humanoid robots operating in human environments.",sidebar_position:15,wordCount:"1300-1600",prerequisites:"Safety engineering and risk assessment principles",learningOutcomes:["Implement safety systems that protect humans and robots","Apply safety standards to humanoid robot design","Conduct risk assessments for physical AI systems"],subtopics:["Safety standards and regulations","Collision avoidance and safe interaction","Emergency stop and fail-safe mechanisms","Risk assessment and mitigation","Human safety in close proximity operations"],status:"draft",authors:["Textbook Author"],reviewers:["Domain Expert"]},r="Safety and Compliance in Physical AI",c={},l=[{value:"Safety Standards and Regulations",id:"safety-standards-and-regulations",level:2},{value:"Collision Avoidance and Safe Interaction",id:"collision-avoidance-and-safe-interaction",level:2},{value:"Emergency Stop and Fail-Safe Mechanisms",id:"emergency-stop-and-fail-safe-mechanisms",level:2},{value:"Risk Assessment and Mitigation",id:"risk-assessment-and-mitigation",level:2},{value:"Human Safety in Close Proximity Operations",id:"human-safety-in-close-proximity-operations",level:2},{value:"Advanced Safety Techniques",id:"advanced-safety-techniques",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"safety-and-compliance-in-physical-ai",children:"Safety and Compliance in Physical AI"})}),"\n",(0,i.jsx)(n.p,{children:"Safety is paramount in humanoid robotics, as these systems operate in close proximity to humans in everyday environments. Unlike industrial robots that operate behind safety barriers, humanoid robots must interact safely with humans while performing complex tasks. This requires sophisticated safety systems that can prevent harm under normal operation as well as fault conditions."}),"\n",(0,i.jsx)(n.p,{children:"The safety requirements for humanoid robots encompass both hardware and software aspects, requiring redundant systems, fail-safe mechanisms, and comprehensive risk assessment. Regulatory compliance adds additional complexity, as different jurisdictions have varying safety standards for robots operating in public spaces."}),"\n",(0,i.jsx)(n.h2,{id:"safety-standards-and-regulations",children:"Safety Standards and Regulations"}),"\n",(0,i.jsx)(n.p,{children:"Safety standards for humanoid robots draw from multiple domains, including industrial robotics, consumer products, and medical devices. The ISO 13482 standard specifically addresses safety requirements for personal care robots, providing guidelines for collision avoidance, force limitation, and emergency stopping."}),"\n",(0,i.jsx)(n.p,{children:"International standards organizations like ISO and IEC have developed frameworks for robot safety, including ISO 10218 for industrial robots and ISO 13482 for service robots. These standards provide guidelines for risk assessment, safety-related control systems, and performance requirements."}),"\n",(0,i.jsx)(n.p,{children:"Compliance with safety standards typically requires extensive testing and certification processes. This includes electromagnetic compatibility (EMC) testing, safety validation, and in some cases, clinical trials for medical applications."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"When designing safety systems for humanoid robots, follow the hierarchy of controls: eliminate hazards where possible, substitute safer alternatives, implement engineering controls, use administrative controls, and finally provide personal protective equipment."})}),"\n",(0,i.jsx)(n.h2,{id:"collision-avoidance-and-safe-interaction",children:"Collision Avoidance and Safe Interaction"}),"\n",(0,i.jsx)(n.p,{children:"Collision avoidance systems for humanoid robots must operate in complex, dynamic environments with unpredictable human movement patterns. This requires sophisticated perception and prediction systems that can detect and classify nearby objects and anticipate their movement."}),"\n",(0,i.jsx)(n.p,{children:"The safety system must distinguish between different types of contacts: intentional light contact during interaction, unintentional contact that should be avoided, and impacts that could cause injury. This requires force and tactile sensing systems that can provide real-time feedback about contact forces and characteristics."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial.distance import cdist\nimport matplotlib.pyplot as plt\nfrom enum import Enum\n\nclass SafetyLevel(Enum):\n    SAFE = 0\n    WARNING = 1\n    DANGER = 2\n    EMERGENCY = 3\n\nclass CollisionAvoidanceSystem:\n    \"\"\"\n    Collision avoidance system for humanoid robot\n    \"\"\"\n    def __init__(self):\n        self.safety_zones = {\n            'red': 0.1,      # 10cm - immediate danger\n            'yellow': 0.3,   # 30cm - caution zone\n            'green': 0.5     # 50cm - safe zone\n        }\n\n        self.collision_thresholds = {\n            'static_objects': 0.2,  # 20cm minimum distance\n            'moving_objects': 0.3,  # 30cm minimum distance\n            'humans': 0.4           # 40cm minimum distance\n        }\n\n        self.safety_responses = {\n            'reduce_speed': 0.5,\n            'change_direction': 0.7,\n            'stop': 0.9,\n            'emergency_stop': 1.0\n        }\n\n        self.object_classifier = {\n            'human': {'priority': 1, 'risk_multiplier': 2.0},\n            'obstacle': {'priority': 2, 'risk_multiplier': 1.0},\n            'robot': {'priority': 3, 'risk_multiplier': 1.5}\n        }\n\n    def detect_objects_in_proximity(self, robot_position, sensor_data):\n        \"\"\"\n        Detect objects in proximity to robot\n        sensor_data: list of [x, y, z, classification] for detected objects\n        \"\"\"\n        detections = []\n        for obj in sensor_data:\n            x, y, z, obj_class = obj\n            obj_pos = np.array([x, y, z])\n            distance = np.linalg.norm(robot_position - obj_pos)\n\n            # Classify danger level based on distance and object type\n            safety_level = self._classify_safety_level(distance, obj_class)\n            risk_score = self._calculate_risk_score(distance, obj_class)\n\n            detections.append({\n                'position': obj_pos,\n                'classification': obj_class,\n                'distance': distance,\n                'safety_level': safety_level,\n                'risk_score': risk_score\n            })\n\n        return detections\n\n    def _classify_safety_level(self, distance, obj_class):\n        \"\"\"\n        Classify safety level based on distance and object type\n        \"\"\"\n        if obj_class == 'human':\n            threshold = self.collision_thresholds['humans']\n        elif obj_class == 'robot':\n            threshold = self.collision_thresholds['moving_objects']\n        else:\n            threshold = self.collision_thresholds['static_objects']\n\n        if distance < threshold * 0.5:\n            return SafetyLevel.EMERGENCY\n        elif distance < threshold:\n            return SafetyLevel.DANGER\n        elif distance < threshold * 1.5:\n            return SafetyLevel.WARNING\n        else:\n            return SafetyLevel.SAFE\n\n    def _calculate_risk_score(self, distance, obj_class):\n        \"\"\"\n        Calculate numerical risk score based on distance and object classification\n        \"\"\"\n        # Normalize distance to 0-1 scale (higher risk at closer distances)\n        if obj_class == 'human':\n            max_distance = self.collision_thresholds['humans'] * 2\n        elif obj_class == 'robot':\n            max_distance = self.collision_thresholds['moving_objects'] * 2\n        else:\n            max_distance = self.collision_thresholds['static_objects'] * 2\n\n        normalized_distance = min(1.0, distance / max_distance)\n        distance_risk = 1.0 - normalized_distance  # Higher risk at closer distances\n\n        # Apply object-specific risk multiplier\n        obj_risk_mult = self.object_classifier.get(obj_class, {}).get('risk_multiplier', 1.0)\n\n        risk_score = distance_risk * obj_risk_mult\n        return min(1.0, risk_score)  # Cap at 1.0\n\n    def plan_avoidance_maneuver(self, robot_position, robot_velocity, detections):\n        \"\"\"\n        Plan avoidance maneuver based on detected objects\n        \"\"\"\n        if not detections:\n            return None  # No obstacles to avoid\n\n        # Identify highest-risk objects\n        high_risk_objects = [det for det in detections if det['risk_score'] > 0.5]\n\n        if not high_risk_objects:\n            return None  # No high-risk objects\n\n        # Calculate repulsive forces from each object\n        total_force = np.array([0.0, 0.0, 0.0])\n        for obj in high_risk_objects:\n            # Vector from object to robot\n            direction = robot_position - obj['position']\n            distance = obj['distance']\n\n            # Calculate repulsive force (inverse square law)\n            if distance > 0.01:  # Avoid division by zero\n                magnitude = 1.0 / (distance ** 2)\n                force = (direction / distance) * magnitude\n                total_force += force\n\n        # Normalize and scale the avoidance force\n        if np.linalg.norm(total_force) > 0:\n            avoidance_direction = total_force / np.linalg.norm(total_force)\n            avoidance_velocity = avoidance_direction * np.linalg.norm(robot_velocity) * 0.8\n        else:\n            avoidance_velocity = np.array([0.0, 0.0, 0.0])\n\n        return {\n            'avoidance_direction': avoidance_direction if np.linalg.norm(total_force) > 0 else None,\n            'new_velocity': avoidance_velocity,\n            'suggested_action': 'adjust_path' if np.linalg.norm(avoidance_velocity) > 0.1 else 'continue'\n        }\n\n    def calculate_safe_collision_force(self, mass, velocity, collision_time=0.1):\n        \"\"\"\n        Calculate safe collision force using impulse-momentum theorem\n        collision_time: time over which collision occurs (default 0.1s)\n        \"\"\"\n        # For human safety, typical maximum safe impact force is ~100N\n        max_safe_force = 100.0  # Newtons\n\n        # Calculate momentum change\n        momentum_change = mass * velocity\n\n        # Calculate required collision time for safe force\n        required_time = momentum_change / max_safe_force\n\n        # Calculate force for given collision time\n        collision_force = momentum_change / collision_time\n\n        return {\n            'momentum_change': momentum_change,\n            'collision_force': collision_force,\n            'max_safe_force': max_safe_force,\n            'required_duration_for_safety': required_time,\n            'is_safe': collision_force <= max_safe_force\n        }\n\nclass ForceLimitingSystem:\n    \"\"\"\n    Force limiting system to prevent injury during contact\n    \"\"\"\n    def __init__(self):\n        self.force_limits = {\n            'limbs': 150,      # 150N maximum force\n            'torso': 200,      # 200N maximum force\n            'head': 100,       # 100N maximum force\n            'hands': 50        # 50N maximum force for delicate interaction\n        }\n\n        self.torque_limits = {\n            'joint': 100,      # 100 Nm maximum torque per joint\n            'actuator': 150    # 150 Nm maximum torque per actuator\n        }\n\n        self.response_times = {\n            'soft_contact': 0.05,   # 50ms for soft contact\n            'firm_contact': 0.02,   # 20ms for firm contact\n            'impact': 0.005         # 5ms for impact\n        }\n\n    def monitor_contact_force(self, contact_points, force_readings):\n        \"\"\"\n        Monitor contact forces at multiple points\n        contact_points: list of (x, y, z) coordinates of contact\n        force_readings: list of (fx, fy, fz) force vectors at each contact point\n        \"\"\"\n        safety_status = {\n            'contacts': [],\n            'max_force_exceeded': False,\n            'safety_action_required': False,\n            'recommended_action': None\n        }\n\n        for i, (contact_pos, force_vec) in enumerate(zip(contact_points, force_readings)):\n            force_magnitude = np.linalg.norm(force_vec)\n\n            # Determine which body part is involved\n            body_part = self._identify_body_part(contact_pos)\n            max_allowed_force = self.force_limits.get(body_part, 150)\n\n            contact_info = {\n                'position': contact_pos,\n                'force_vector': force_vec,\n                'force_magnitude': force_magnitude,\n                'body_part': body_part,\n                'max_allowed_force': max_allowed_force,\n                'force_ratio': force_magnitude / max_allowed_force,\n                'is_safe': force_magnitude <= max_allowed_force\n            }\n\n            safety_status['contacts'].append(contact_info)\n\n            if not contact_info['is_safe']:\n                safety_status['max_force_exceeded'] = True\n                safety_status['safety_action_required'] = True\n\n                # Determine appropriate response based on force magnitude\n                if contact_info['force_ratio'] > 2.0:\n                    safety_status['recommended_action'] = 'emergency_stop'\n                elif contact_info['force_ratio'] > 1.5:\n                    safety_status['recommended_action'] = 'reduce_force_immediately'\n                else:\n                    safety_status['recommended_action'] = 'reduce_force_gradually'\n\n        return safety_status\n\n    def _identify_body_part(self, position):\n        \"\"\"\n        Identify which body part is at given position\n        This is a simplified model - in practice, this would use the robot's kinematic model\n        \"\"\"\n        x, y, z = position\n\n        # Simplified body part identification based on position\n        if z > 1.2:  # Above waist\n            if abs(y) < 0.2:  # Center\n                return 'head'\n            else:\n                return 'limbs'\n        elif z > 0.5:  # Waist to chest area\n            return 'torso'\n        else:  # Below waist\n            return 'limbs'\n\n    def calculate_impact_absorption(self, impact_force, body_part):\n        \"\"\"\n        Calculate how much impact force can be absorbed by compliant mechanisms\n        \"\"\"\n        # Different body parts have different compliance characteristics\n        compliance_factors = {\n            'head': 0.8,    # Highly compliant\n            'torso': 0.6,   # Moderately compliant\n            'limbs': 0.4,   # Less compliant\n            'hands': 0.9    # Most compliant\n        }\n\n        factor = compliance_factors.get(body_part, 0.5)\n        absorbed_force = impact_force * factor\n        transmitted_force = impact_force * (1 - factor)\n\n        return {\n            'impact_force': impact_force,\n            'absorbed_force': absorbed_force,\n            'transmitted_force': transmitted_force,\n            'compliance_factor': factor,\n            'body_part': body_part\n        }\n\nclass RiskAssessmentSystem:\n    \"\"\"\n    System for conducting risk assessments on humanoid robot operations\n    \"\"\"\n    def __init__(self):\n        self.hazard_categories = [\n            'mechanical_hazards',\n            'electrical_hazards',\n            'thermal_hazards',\n            'radiation_hazards',\n            'chemical_hazards',\n            'information_security'\n        ]\n\n        self.risk_matrix = {\n            'probability': {\n                'rare': 1,\n                'unlikely': 2,\n                'possible': 3,\n                'likely': 4,\n                'almost_certain': 5\n            },\n            'severity': {\n                'negligible': 1,\n                'minor': 2,\n                'moderate': 3,\n                'major': 4,\n                'catastrophic': 5\n            }\n        }\n\n    def conduct_risk_assessment(self, robot_config, operational_scenario):\n        \"\"\"\n        Conduct comprehensive risk assessment\n        \"\"\"\n        risks = []\n\n        # Assess each hazard category\n        for hazard_cat in self.hazard_categories:\n            category_risks = self._assess_hazard_category(hazard_cat, robot_config, operational_scenario)\n            risks.extend(category_risks)\n\n        # Calculate overall risk score\n        total_risk_score = sum([risk['risk_score'] for risk in risks])\n        average_risk_score = total_risk_score / len(risks) if risks else 0\n\n        return {\n            'risks_identified': risks,\n            'total_risk_score': total_risk_score,\n            'average_risk_score': average_risk_score,\n            'highest_risk_items': sorted(risks, key=lambda x: x['risk_score'], reverse=True)[:3],\n            'risk_mitigation_recommendations': self._generate_mitigation_strategies(risks)\n        }\n\n    def _assess_hazard_category(self, hazard_cat, robot_config, scenario):\n        \"\"\"\n        Assess risks within a specific hazard category\n        \"\"\"\n        risks = []\n\n        if hazard_cat == 'mechanical_hazards':\n            # Assess risks from moving parts, pinch points, collision\n            risks.append({\n                'hazard_type': 'collision',\n                'description': 'Risk of collision with humans during operation',\n                'probability': 'likely',\n                'severity': 'major',\n                'existing_controls': ['collision_detection', 'speed_limiting'],\n                'residual_probability': 'possible',\n                'risk_score': 12  # 4 (likely) * 3 (major severity)\n            })\n\n            risks.append({\n                'hazard_type': 'pinch_points',\n                'description': 'Risk of fingers getting caught in joints',\n                'probability': 'possible',\n                'severity': 'minor',\n                'existing_controls': ['guarding', 'force_limiting'],\n                'residual_probability': 'rare',\n                'risk_score': 3  # 1 (rare) * 3 (minor severity)\n            })\n\n        elif hazard_cat == 'electrical_hazards':\n            # Assess risks from electrical systems\n            risks.append({\n                'hazard_type': 'electric_shock',\n                'description': 'Risk of electric shock from exposed wiring',\n                'probability': 'unlikely',\n                'severity': 'major',\n                'existing_controls': ['grounding', 'insulation', 'circuit_breakers'],\n                'residual_probability': 'rare',\n                'risk_score': 2  # 1 (rare) * 2 (major severity)\n            })\n\n        elif hazard_cat == 'thermal_hazards':\n            # Assess risks from heat generation\n            risks.append({\n                'hazard_type': 'burns',\n                'description': 'Risk of burns from hot surfaces',\n                'probability': 'possible',\n                'severity': 'minor',\n                'existing_controls': ['thermal insulation', 'temperature monitoring'],\n                'residual_probability': 'unlikely',\n                'risk_score': 4  # 2 (unlikely) * 2 (minor severity)\n            })\n\n        # Add other hazard categories as needed...\n\n        return risks\n\n    def _generate_mitigation_strategies(self, risks):\n        \"\"\"\n        Generate mitigation strategies based on identified risks\n        \"\"\"\n        strategies = {\n            'elimination': [],\n            'engineering': [],\n            'administrative': [],\n            'protective_equipment': []\n        }\n\n        for risk in risks:\n            if risk['risk_score'] > 10:  # High risk items\n                if risk['hazard_type'] in ['collision', 'pinch_points']:\n                    strategies['engineering'].append(\n                        f\"Implement redundant collision detection systems for {risk['hazard_type']}\"\n                    )\n                elif risk['hazard_type'] == 'electric_shock':\n                    strategies['engineering'].append(\n                        f\"Install ground fault circuit interrupters for electrical safety\"\n                    )\n\n        return strategies\n\n    def update_safety_protocol(self, new_threats):\n        \"\"\"\n        Update safety protocols based on new threat information\n        \"\"\"\n        protocol_updates = []\n\n        for threat in new_threats:\n            if threat['severity'] >= 4:  # Major or catastrophic\n                protocol_updates.append({\n                    'update_type': 'immediate',\n                    'description': f\"New high-severity threat: {threat['description']}\",\n                    'required_action': 'implement_new_safety_measures'\n                })\n            elif threat['severity'] >= 2:  # Minor or moderate\n                protocol_updates.append({\n                    'update_type': 'scheduled',\n                    'description': f\"New medium-severity threat: {threat['description']}\",\n                    'required_action': 'review_and_update_protocols'\n                })\n\n        return protocol_updates\n"})}),"\n",(0,i.jsx)(n.h2,{id:"emergency-stop-and-fail-safe-mechanisms",children:"Emergency Stop and Fail-Safe Mechanisms"}),"\n",(0,i.jsx)(n.p,{children:"Emergency stop systems must be able to bring the humanoid robot to a safe state within required timeframes, typically within tens of milliseconds. These systems must operate independently of the primary control system to ensure functionality even in case of control system failures."}),"\n",(0,i.jsx)(n.p,{children:"Redundant emergency stop systems are typically required, with multiple activation methods including physical buttons, software commands, and communication timeouts. The system must also provide clear indication of emergency stop status to operators and prevent restart until the cause of the emergency stop is addressed."}),"\n",(0,i.jsx)(n.p,{children:"Fail-safe mechanisms ensure that in case of system failures, the robot assumes a safe state. This might involve cutting power to actuators to allow passive compliance, engaging mechanical brakes, or moving to a predetermined safe configuration."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <vector>\n#include <memory>\n#include <mutex>\n#include <chrono>\n#include <atomic>\n#include <functional>\n\nclass EmergencyStopSystem {\nprivate:\n    std::atomic<bool> emergency_active;\n    std::atomic<bool> system_enabled;\n    std::chrono::steady_clock::time_point last_communication;\n    std::mutex state_mutex;\n    std::vector<std::function<void()>> safety_callbacks;\n\npublic:\n    EmergencyStopSystem() : emergency_active(false), system_enabled(true) {\n        last_communication = std::chrono::steady_clock::now();\n    }\n\n    void activate_emergency_stop() {\n        std::lock_guard<std::mutex> lock(state_mutex);\n        emergency_active = true;\n        system_enabled = false;\n\n        // Execute registered safety callbacks\n        for (const auto& callback : safety_callbacks) {\n            callback();\n        }\n\n        // Log emergency event\n        log_emergency_event("Emergency stop activated");\n    }\n\n    void deactivate_emergency_stop() {\n        std::lock_guard<std::mutex> lock(state_mutex);\n        emergency_active = false;\n        system_enabled = true;\n    }\n\n    bool is_emergency_active() const {\n        return emergency_active.load();\n    }\n\n    bool is_system_enabled() const {\n        return system_enabled.load();\n    }\n\n    void update_communication_timestamp() {\n        std::lock_guard<std::mutex> lock(state_mutex);\n        last_communication = std::chrono::steady_clock::now();\n    }\n\n    void check_communication_timeout(int timeout_ms = 100) {\n        std::lock_guard<std::mutex> lock(state_mutex);\n        auto now = std::chrono::steady_clock::now();\n        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_communication);\n\n        if (elapsed.count() > timeout_ms && !emergency_active) {\n            activate_emergency_stop();\n            log_emergency_event("Communication timeout - emergency stop activated");\n        }\n    }\n\n    void register_safety_callback(std::function<void()> callback) {\n        std::lock_guard<std::mutex> lock(state_mutex);\n        safety_callbacks.push_back(callback);\n    }\n\nprivate:\n    void log_emergency_event(const std::string& message) {\n        // In a real system, this would log to a persistent emergency log\n        std::cout << "[" << std::chrono::duration_cast<std::chrono::milliseconds>(\n            std::chrono::steady_clock::now().time_since_epoch()).count() << "] EMERGENCY: "\n                  << message << std::endl;\n    }\n};\n\nclass FailSafeManager {\nprivate:\n    std::atomic<bool> in_fail_safe_mode;\n    std::vector<std::pair<double, std::function<void()>>> safety_actions;  // threshold, action\n    std::mutex safety_mutex;\n    double current_risk_level;\n\npublic:\n    FailSafeManager() : in_fail_safe_mode(false), current_risk_level(0.0) {}\n\n    void register_safety_action(double threshold, std::function<void()> action) {\n        std::lock_guard<std::mutex> lock(safety_mutex);\n        safety_actions.push_back(std::make_pair(threshold, action));\n    }\n\n    void update_risk_level(double new_risk) {\n        std::lock_guard<std::mutex> lock(safety_mutex);\n        current_risk_level = new_risk;\n\n        // Check if we need to enter fail-safe mode\n        if (new_risk > 0.8 && !in_fail_safe_mode) {  // High risk threshold\n            enter_fail_safe_mode();\n        } else if (new_risk < 0.3 && in_fail_safe_mode) {  // Low risk threshold\n            exit_fail_safe_mode();\n        }\n\n        // Execute safety actions based on risk level\n        for (const auto& action_pair : safety_actions) {\n            if (new_risk >= action_pair.first) {\n                action_pair.second();\n            }\n        }\n    }\n\n    void enter_fail_safe_mode() {\n        in_fail_safe_mode = true;\n\n        // Implement fail-safe actions\n        reduce_speed_to_safe_level();\n        move_to_safe_position();\n        engage_safety_brakes();\n    }\n\n    void exit_fail_safe_mode() {\n        in_fail_safe_mode = false;\n\n        // Resume normal operation cautiously\n        gradual_power_restoration();\n    }\n\n    bool is_in_fail_safe_mode() const {\n        return in_fail_safe_mode.load();\n    }\n\nprivate:\n    void reduce_speed_to_safe_level() {\n        // Reduce all actuator speeds to safe minimum\n        std::cout << "Reducing speeds to safe levels" << std::endl;\n    }\n\n    void move_to_safe_position() {\n        // Move robot to predetermined safe configuration\n        std::cout << "Moving to safe position" << std::endl;\n    }\n\n    void engage_safety_brakes() {\n        // Engage mechanical safety brakes\n        std::cout << "Engaging safety brakes" << std::endl;\n    }\n\n    void gradual_power_restoration() {\n        // Gradually restore power in safe manner\n        std::cout << "Gradually restoring power" << std::endl;\n    }\n};\n\nclass SafetyController {\nprivate:\n    std::shared_ptr<EmergencyStopSystem> em_stop_sys;\n    std::shared_ptr<FailSafeManager> fail_safe_man;\n    std::vector<double> joint_torque_limits;\n    std::vector<double> joint_position_limits;\n    std::atomic<double> max_force_threshold;\n\npublic:\n    SafetyController(size_t num_joints)\n        : em_stop_sys(std::make_shared<EmergencyStopSystem>()),\n          fail_safe_man(std::make_shared<FailSafeManager>()) {\n\n        joint_torque_limits.resize(num_joints, 100.0);  // Default 100 Nm\n        joint_position_limits.resize(num_joints * 2);   // Min/max for each joint\n        max_force_threshold(200.0);  // Default 200N maximum\n\n        // Register safety callbacks\n        em_stop_sys->register_safety_callback([this]() { this->execute_emergency_stop(); });\n    }\n\n    bool validate_command(const std::vector<double>& torques,\n                         const std::vector<double>& positions) {\n        if (em_stop_sys->is_emergency_active()) {\n            return false;  // No commands allowed during emergency\n        }\n\n        if (torques.size() != joint_torque_limits.size()) {\n            return false;  // Size mismatch\n        }\n\n        // Check torque limits\n        for (size_t i = 0; i < torques.size(); ++i) {\n            if (std::abs(torques[i]) > joint_torque_limits[i]) {\n                std::cout << "Torque limit exceeded for joint " << i << std::endl;\n                return false;\n            }\n        }\n\n        // Check position limits (simplified)\n        for (size_t i = 0; i < positions.size(); ++i) {\n            double min_pos = joint_position_limits[i * 2];\n            double max_pos = joint_position_limits[i * 2 + 1];\n\n            if (positions[i] < min_pos || positions[i] > max_pos) {\n                std::cout << "Position limit exceeded for joint " << i << std::endl;\n                return false;\n            }\n        }\n\n        return true;  // Command is safe\n    }\n\n    void execute_emergency_stop() {\n        // Cut power to all joints immediately\n        std::vector<double> zero_torques(joint_torque_limits.size(), 0.0);\n        apply_joint_torques(zero_torques);\n\n        // Engage safety brakes\n        engage_all_brakes();\n\n        std::cout << "Emergency stop executed - all power cut" << std::endl;\n    }\n\n    void monitor_external_forces(const std::vector<double>& measured_forces) {\n        double max_force = 0.0;\n        for (double force : measured_forces) {\n            max_force = std::max(max_force, std::abs(force));\n        }\n\n        if (max_force > max_force_threshold.load()) {\n            // Trigger safety response based on force level\n            if (max_force > max_force_threshold.load() * 1.5) {\n                em_stop_sys->activate_emergency_stop();\n            } else {\n                // Just log the high force event\n                std::cout << "High external force detected: " << max_force << "N" << std::endl;\n                fail_safe_man->update_risk_level(0.6);  // Medium risk\n            }\n        }\n    }\n\n    void update_communication_timestamp() {\n        em_stop_sys->update_communication_timestamp();\n    }\n\n    void check_safety_systems() {\n        em_stop_sys->check_communication_timeout();\n    }\n\nprivate:\n    void apply_joint_torques(const std::vector<double>& torques) {\n        // In a real system, this would send commands to the joint controllers\n        std::cout << "Applying torques: ";\n        for (double t : torques) std::cout << t << " ";\n        std::cout << std::endl;\n    }\n\n    void engage_all_brakes() {\n        // In a real system, this would engage mechanical brakes on all joints\n        std::cout << "Engaging all joint brakes" << std::endl;\n    }\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"risk-assessment-and-mitigation",children:"Risk Assessment and Mitigation"}),"\n",(0,i.jsx)(n.p,{children:"Risk assessment for humanoid robots requires systematic evaluation of potential hazards and their likelihood of occurrence. This involves identifying potential failure modes, analyzing their consequences, and implementing appropriate mitigation strategies."}),"\n",(0,i.jsx)(n.p,{children:"The risk assessment process should be iterative, with regular updates as the robot system evolves and as new operational experience is gained. This includes both pre-deployment assessments and ongoing monitoring during operation."}),"\n",(0,i.jsx)(n.h2,{id:"human-safety-in-close-proximity-operations",children:"Human Safety in Close Proximity Operations"}),"\n",(0,i.jsx)(n.p,{children:"Operating safely in close proximity to humans requires special consideration of human vulnerability and the unpredictable nature of human movement. Safety systems must account for the fact that humans may behave unexpectedly or make mistakes."}),"\n",(0,i.jsx)(n.p,{children:"Force limitation is particularly important for human safety, as the human body has limited tolerance for impact forces. The ISO standards typically limit contact forces to 150N for non-delicate interactions and lower values for areas like the face or hands."}),"\n",(0,i.jsx)(n.p,{children:"[Image: Reference to diagram or illustration]"}),"\n",(0,i.jsx)(n.h2,{id:"advanced-safety-techniques",children:"Advanced Safety Techniques"}),"\n",(0,i.jsx)(n.p,{children:"Modern humanoid robots employ several advanced safety techniques:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predictive Safety"}),": Using AI to predict potential safety violations before they occur"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adaptive Safety Boundaries"}),": Dynamically adjusting safety zones based on context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Collaborative Safety"}),": Sharing safety information between multiple robots"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Learning-Based Safety"}),": Improving safety performance through experience"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Certified Safety Controllers"}),": Using formally verified safety control algorithms"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Safety and compliance are fundamental requirements for humanoid robots operating in human environments. The challenge lies in creating systems that can operate safely while maintaining the functionality required for useful interaction. Success in safety requires comprehensive risk assessment, robust safety systems, and ongoing monitoring and improvement to address evolving operational conditions and requirements."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);