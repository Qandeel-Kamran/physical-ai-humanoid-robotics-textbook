"use strict";(self.webpackChunkmy_textbook_website=self.webpackChunkmy_textbook_website||[]).push([[403],{5936:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"chapter-06-control-theory","title":"Control Theory for Humanoid Robots","description":"Understanding control theory principles and their application to humanoid robot systems, including stability analysis and real-time implementation.","source":"@site/docs/chapter-06-control-theory.md","sourceDirName":".","slug":"/chapter-06-control-theory","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter-06-control-theory","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Control Theory for Humanoid Robots","description":"Understanding control theory principles and their application to humanoid robot systems, including stability analysis and real-time implementation.","sidebar_position":6,"wordCount":"1500-1800","prerequisites":"Advanced mathematics and control systems theory","learningOutcomes":["Apply control theory to stabilize humanoid robot movements","Design adaptive control systems for dynamic environments","Implement real-time control algorithms for humanoid robots"],"subtopics":["Classical control methods for robotic systems","Model-based control approaches","Adaptive and learning-based control","Stability analysis for bipedal locomotion","Real-time control implementation"],"status":"draft","authors":["Textbook Author"],"reviewers":["Domain Expert"]},"sidebar":"textbookSidebar","previous":{"title":"Actuation Systems and Artificial Muscles","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter-05-actuation"},"next":{"title":"Locomotion and Bipedal Walking","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter-07-locomotion"}}');var i=o(4848),r=o(8453);const a={title:"Control Theory for Humanoid Robots",description:"Understanding control theory principles and their application to humanoid robot systems, including stability analysis and real-time implementation.",sidebar_position:6,wordCount:"1500-1800",prerequisites:"Advanced mathematics and control systems theory",learningOutcomes:["Apply control theory to stabilize humanoid robot movements","Design adaptive control systems for dynamic environments","Implement real-time control algorithms for humanoid robots"],subtopics:["Classical control methods for robotic systems","Model-based control approaches","Adaptive and learning-based control","Stability analysis for bipedal locomotion","Real-time control implementation"],status:"draft",authors:["Textbook Author"],reviewers:["Domain Expert"]},s="Control Theory for Humanoid Robots",l={},d=[{value:"Classical Control Methods for Robotic Systems",id:"classical-control-methods-for-robotic-systems",level:2},{value:"Model-Based Control Approaches",id:"model-based-control-approaches",level:2},{value:"Adaptive and Learning-Based Control",id:"adaptive-and-learning-based-control",level:2},{value:"Stability Analysis for Bipedal Locomotion",id:"stability-analysis-for-bipedal-locomotion",level:2},{value:"Real-Time Control Implementation",id:"real-time-control-implementation",level:2},{value:"Advanced Control Techniques",id:"advanced-control-techniques",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"control-theory-for-humanoid-robots",children:"Control Theory for Humanoid Robots"})}),"\n",(0,i.jsx)(n.p,{children:"Control theory provides the mathematical foundation for enabling humanoid robots to perform stable, coordinated movements in dynamic environments. Unlike simple robotic systems, humanoid robots must maintain balance while executing complex tasks, requiring sophisticated control approaches that can handle multiple constraints and objectives simultaneously."}),"\n",(0,i.jsx)(n.p,{children:"The control of humanoid robots presents unique challenges due to their underactuated nature, complex dynamics, and the need for stable interaction with the environment. Traditional control approaches must be adapted and extended to handle the specific requirements of bipedal locomotion, manipulation, and human-like behavior."}),"\n",(0,i.jsx)(n.h2,{id:"classical-control-methods-for-robotic-systems",children:"Classical Control Methods for Robotic Systems"}),"\n",(0,i.jsx)(n.p,{children:"Classical control methods, including proportional-integral-derivative (PID) control, form the foundation of many robotic control systems. These methods are well-understood, computationally efficient, and provide reliable performance for many robotic applications."}),"\n",(0,i.jsx)(n.p,{children:"PID control adjusts the control output based on the error between the desired and actual states, using proportional, integral, and derivative terms to achieve stable control. The proportional term responds to the current error, the integral term eliminates steady-state error, and the derivative term anticipates future error based on the rate of change."}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, PID controllers are often used in cascade configurations, with high-level trajectory planners providing reference positions to low-level joint controllers that regulate actual joint positions."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"When implementing PID control for humanoid robots, it's crucial to properly tune the gains for each joint, considering the varying dynamics and loads experienced during different phases of motion."})}),"\n",(0,i.jsx)(n.h2,{id:"model-based-control-approaches",children:"Model-Based Control Approaches"}),"\n",(0,i.jsx)(n.p,{children:"Model-based control approaches leverage mathematical models of the robot's dynamics to achieve more precise and efficient control. These methods can account for the complex interactions between joints, the effects of gravity, and the coupling between different parts of the robot."}),"\n",(0,i.jsx)(n.p,{children:"Computed torque control (also known as inverse dynamics control) uses the robot's dynamic model to compute the required joint torques needed to achieve desired accelerations. This approach linearizes the robot's dynamics, allowing for simpler control design in the task space."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.linalg import solve\nimport matplotlib.pyplot as plt\n\nclass HumanoidDynamics:\n    """\n    Model of humanoid robot dynamics using the Euler-Lagrange formulation\n    """\n    def __init__(self, num_joints=12):\n        self.n = num_joints  # Number of joints\n        # Simplified parameters for a 12-DOF humanoid model\n        self.mass_links = np.array([1.0, 1.0, 1.5, 1.5, 2.0, 2.0, 1.0, 1.0, 0.5, 0.5, 0.5, 0.5])\n        self.length_links = np.array([0.3, 0.3, 0.4, 0.4, 0.5, 0.5, 0.3, 0.3, 0.1, 0.1, 0.1, 0.1])\n\n    def mass_matrix(self, q):\n        """\n        Compute the mass matrix H(q) for the humanoid robot\n        """\n        H = np.zeros((self.n, self.n))\n\n        # Simplified mass matrix calculation\n        # In reality, this would involve complex geometric and inertial calculations\n        for i in range(self.n):\n            # Diagonal terms include link masses and inertias\n            H[i, i] = self.mass_links[i] * self.length_links[i]**2\n\n            # Off-diagonal terms for coupled joints\n            for j in range(i+1, self.n):\n                # Simplified coupling based on joint proximity\n                coupling = 0.1 * np.cos(q[i] - q[j])\n                H[i, j] = coupling\n                H[j, i] = coupling\n\n        return H\n\n    def coriolis_gravity_matrix(self, q, q_dot):\n        """\n        Compute the Coriolis and gravity matrix C(q,q_dot) + g(q)\n        """\n        Cg = np.zeros(self.n)\n\n        for i in range(self.n):\n            # Coriolis terms (simplified)\n            Cg[i] += 0.1 * self.mass_links[i] * q_dot[i]**2 * np.sin(q[i])\n\n            # Gravity terms (simplified)\n            Cg[i] += self.mass_links[i] * 9.81 * np.sin(q[i])\n\n            # Coupling with other joints\n            for j in range(self.n):\n                if i != j:\n                    Cg[i] += 0.05 * self.mass_links[j] * q_dot[j]**2 * np.sin(q[i] - q[j])\n\n        return Cg\n\nclass ComputedTorqueController:\n    """\n    Computed Torque Controller for humanoid robot\n    """\n    def __init__(self, dynamics_model, kp_diag=100, kd_diag=20):\n        self.dyn = dynamics_model\n        self.n = dynamics_model.n\n\n        # Control gains (diagonal matrices)\n        self.Kp = np.eye(self.n) * kp_diag\n        self.Kd = np.eye(self.n) * kd_diag\n\n    def compute_control(self, q, q_dot, q_desired, qd_desired, qdd_desired):\n        """\n        Compute control torques using computed torque method\n        """\n        # Get current dynamics\n        H = self.dyn.mass_matrix(q)\n        Cg = self.dyn.coriolis_gravity_matrix(q, q_dot)\n\n        # Compute control error\n        q_error = q_desired - q\n        qd_error = qd_desired - q_dot\n\n        # Compute auxiliary acceleration\n        v = qdd_desired + self.Kp @ q_error + self.Kd @ qd_error\n\n        # Compute required torques\n        tau = H @ v + Cg\n\n        return tau\n\nclass OperationalSpaceController:\n    """\n    Operational Space Controller for task-space control\n    """\n    def __init__(self, dynamics_model, task_jacobian_func):\n        self.dyn = dynamics_model\n        self.n = dynamics_model.n\n        self.jacobian_func = task_jacobian_func  # Function to compute task Jacobian\n\n    def compute_control(self, q, q_dot, x_desired, xd_desired, xdd_desired,\n                       Kp_task=100, Kd_task=20):\n        """\n        Compute operational space control\n        """\n        # Get current dynamics\n        H = self.dyn.mass_matrix(q)\n        Cg = self.dyn.coriolis_gravity_matrix(q, q_dot)\n\n        # Compute task Jacobian and its derivative\n        J = self.jacobian_func(q)\n        J_dot_q_dot = np.zeros(J.shape[0])  # Simplified\n\n        # Compute operational space inertia\n        lambda_inv = J @ np.linalg.inv(H) @ J.T\n        lambda_task = np.linalg.inv(lambda_inv)\n\n        # Compute task-space error\n        x_current = self.forward_kinematics(q)  # Simplified\n        x_error = x_desired - x_current\n        xd_current = J @ q_dot\n        xd_error = xd_desired - xd_current\n\n        # Compute desired task-space force\n        F_task = lambda_task @ (xdd_desired + Kp_task * x_error + Kd_task * xd_error)\n\n        # Transform to joint space\n        tau = J.T @ F_task + Cg  # Add gravity and Coriolis compensation\n\n        return tau\n\n    def forward_kinematics(self, q):\n        """\n        Simplified forward kinematics (in practice, this would be more complex)\n        """\n        # Return simplified end-effector position\n        return np.array([np.sum(np.sin(q[:3])), np.sum(np.cos(q[:3])), 0.0])\n\nclass ZeroMomentPointController:\n    """\n    ZMP-based controller for bipedal stability\n    """\n    def __init__(self, robot_height=0.8, gravity=9.81):\n        self.height = robot_height\n        self.g = gravity\n        self.omega = np.sqrt(self.g / self.height)\n\n    def compute_zmp(self, com_pos, com_vel, com_acc):\n        """\n        Compute Zero Moment Point from center of mass state\n        """\n        zmp_x = com_pos[0] - (com_acc[0] / self.g) * self.height\n        zmp_y = com_pos[1] - (com_acc[1] / self.g) * self.height\n        return np.array([zmp_x, zmp_y])\n\n    def plan_com_trajectory(self, initial_com, final_com, duration, dt=0.01):\n        """\n        Plan CoM trajectory using 3rd order polynomial\n        """\n        t = np.arange(0, duration, dt)\n        trajectory = []\n\n        for ti in t:\n            # 3rd order polynomial interpolation\n            if ti <= duration:\n                ratio = ti / duration\n                pos = initial_com + (final_com - initial_com) * (3*ratio**2 - 2*ratio**3)\n                vel = (final_com - initial_com) * (6*ratio - 6*ratio**2) / duration\n                acc = (final_com - initial_com) * (6 - 12*ratio) / duration**2\n            else:\n                pos = final_com\n                vel = np.zeros_like(pos)\n                acc = np.zeros_like(pos)\n\n            trajectory.append((pos, vel, acc))\n\n        return trajectory\n'})}),"\n",(0,i.jsx)(n.h2,{id:"adaptive-and-learning-based-control",children:"Adaptive and Learning-Based Control"}),"\n",(0,i.jsx)(n.p,{children:"Adaptive control methods adjust their parameters in real-time to compensate for uncertainties in the robot model or changes in the environment. These approaches are particularly valuable for humanoid robots, which must operate in dynamic environments with varying payloads and surface conditions."}),"\n",(0,i.jsx)(n.p,{children:"Model Reference Adaptive Control (MRAC) uses a reference model to define desired behavior and adjusts controller parameters to minimize the error between the actual system and the reference model. This approach can handle parametric uncertainties in the robot dynamics."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"#include <Eigen/Dense>\n#include <vector>\n#include <cmath>\n\nclass AdaptiveController {\nprivate:\n    int n;  // Number of parameters to adapt\n    Eigen::VectorXd theta;  // Parameter estimates\n    Eigen::MatrixXd P;      // Covariance matrix\n    double gamma;           // Adaptation gain\n    Eigen::VectorXd reference_model;\n    Eigen::VectorXd control_output;\n\npublic:\n    AdaptiveController(int param_count, double gain = 0.1)\n        : n(param_count), gamma(gain) {\n        theta = Eigen::VectorXd::Zero(n);\n        P = Eigen::MatrixXd::Identity(n, n) * 1000.0;  // High initial uncertainty\n        reference_model = Eigen::VectorXd::Zero(n);\n        control_output = Eigen::VectorXd::Zero(n);\n    }\n\n    Eigen::VectorXd update(const Eigen::VectorXd& state_error,\n                          const Eigen::VectorXd& regressor,\n                          const Eigen::VectorXd& reference_signal) {\n        // Calculate prediction error\n        double error = state_error.norm();\n\n        // Calculate parameter update\n        Eigen::VectorXd phi = regressor;\n        Eigen::VectorXd temp = P * phi;\n        double denominator = 1.0 + phi.dot(temp);\n        Eigen::VectorXd param_update = (gamma / denominator) * temp * error;\n\n        // Update parameter estimates\n        theta += param_update;\n\n        // Update covariance matrix (covariance resetting algorithm)\n        P = (P - (temp * temp.transpose()) / denominator) / gamma;\n        P = (P + P.transpose()) * 0.5;  // Ensure symmetry\n\n        // Ensure positive definiteness\n        Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> es(P);\n        Eigen::VectorXd eigenvalues = es.eigenvalues();\n        eigenvalues = eigenvalues.cwiseMax(0.01);  // Minimum eigenvalue\n        P = es.eigenvectors() * eigenvalues.asDiagonal() * es.eigenvectors().transpose();\n\n        // Calculate control output\n        control_output = reference_signal + theta;\n\n        return control_output;\n    }\n\n    void setReferenceModel(const Eigen::VectorXd& ref_model) {\n        reference_model = ref_model;\n    }\n\n    Eigen::VectorXd getParameters() const {\n        return theta;\n    }\n};\n\nclass LearningBasedController {\nprivate:\n    // Neural network weights (simplified)\n    Eigen::MatrixXd W_input_hidden;\n    Eigen::MatrixXd W_hidden_output;\n    Eigen::VectorXd bias_hidden;\n    Eigen::VectorXd bias_output;\n    double learning_rate;\n\n    // For reinforcement learning\n    std::vector<std::pair<Eigen::VectorXd, double>> experience_buffer;\n    size_t max_buffer_size;\n\npublic:\n    LearningBasedController(int input_size, int hidden_size, int output_size)\n        : learning_rate(0.01), max_buffer_size(1000) {\n        // Initialize random weights\n        W_input_hidden = Eigen::MatrixXd::Random(hidden_size, input_size) * 0.5;\n        W_hidden_output = Eigen::MatrixXd::Random(output_size, hidden_size) * 0.5;\n        bias_hidden = Eigen::VectorXd::Random(hidden_size) * 0.1;\n        bias_output = Eigen::VectorXd::Random(output_size) * 0.1;\n    }\n\n    Eigen::VectorXd forward(const Eigen::VectorXd& input) {\n        // Forward pass through neural network\n        Eigen::VectorXd hidden = (W_input_hidden * input + bias_hidden).array().tanh();\n        Eigen::VectorXd output = W_hidden_output * hidden + bias_output;\n        return output;\n    }\n\n    void update_weights(const Eigen::VectorXd& input, const Eigen::VectorXd& target) {\n        // Forward pass\n        Eigen::VectorXd hidden_input = W_input_hidden * input + bias_hidden;\n        Eigen::VectorXd hidden_output = hidden_input.array().tanh();\n        Eigen::VectorXd network_output = W_hidden_output * hidden_output + bias_output;\n\n        // Calculate errors\n        Eigen::VectorXd output_error = target - network_output;\n        Eigen::VectorXd hidden_error = W_hidden_output.transpose() * output_error.array() *\n                                      (1.0 - hidden_output.array().square());\n\n        // Update weights using gradient descent\n        W_hidden_output += learning_rate * output_error * hidden_output.transpose();\n        bias_output += learning_rate * output_error;\n\n        W_input_hidden += learning_rate * hidden_error * input.transpose();\n        bias_hidden += learning_rate * hidden_error;\n    }\n\n    void store_experience(const Eigen::VectorXd& state, double reward) {\n        experience_buffer.push_back(std::make_pair(state, reward));\n        if (experience_buffer.size() > max_buffer_size) {\n            experience_buffer.erase(experience_buffer.begin());\n        }\n    }\n\n    void experience_replay() {\n        // Simplified experience replay for learning improvement\n        for (const auto& experience : experience_buffer) {\n            // In practice, this would sample random experiences\n            // and update the controller based on them\n        }\n    }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"stability-analysis-for-bipedal-locomotion",children:"Stability Analysis for Bipedal Locomotion"}),"\n",(0,i.jsx)(n.p,{children:"Stability analysis is crucial for bipedal humanoid robots, as they must maintain balance while walking, standing, or performing tasks. The Zero Moment Point (ZMP) criterion is widely used to ensure dynamic stability during locomotion."}),"\n",(0,i.jsx)(n.p,{children:"The ZMP is the point on the ground where the net moment of the ground reaction forces is zero. For stable walking, the ZMP must remain within the support polygon defined by the feet in contact with the ground."}),"\n",(0,i.jsx)(n.h2,{id:"real-time-control-implementation",children:"Real-Time Control Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Real-time control implementation for humanoid robots requires careful consideration of computational constraints and timing requirements. Control loops must execute at high frequencies (typically 100-1000 Hz) to ensure stable and responsive behavior."}),"\n",(0,i.jsx)(n.p,{children:"Modern humanoid robots use hierarchical control architectures that separate high-level planning from low-level control. Model Predictive Control (MPC) is increasingly popular for humanoid robots, as it can handle multiple constraints and objectives simultaneously while providing robust performance."}),"\n",(0,i.jsx)(n.p,{children:"[Image: Reference to diagram or illustration]"}),"\n",(0,i.jsx)(n.h2,{id:"advanced-control-techniques",children:"Advanced Control Techniques"}),"\n",(0,i.jsx)(n.p,{children:"Several advanced control techniques are particularly relevant for humanoid robotics:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Whole-Body Control"}),": Coordinates multiple tasks simultaneously (balance, manipulation, walking) using optimization-based approaches"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Impedance Control"}),": Regulates the dynamic relationship between position and force for safe interaction"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hybrid Position-Force Control"}),": Combines position and force control for contact tasks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robust Control"}),": Handles model uncertainties and disturbances"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Control theory provides the essential mathematical tools for enabling stable, coordinated movement in humanoid robots. The complexity of humanoid dynamics requires sophisticated control approaches that can handle multiple constraints, uncertainties, and real-time requirements. As humanoid robotics continues to advance, control methods will need to become increasingly sophisticated to enable truly human-like behavior and interaction capabilities."}),"\n",(0,i.jsx)(n.p,{children:"The integration of classical control methods with adaptive and learning-based approaches represents the future of humanoid robot control, enabling systems that can adapt to new situations and improve their performance over time."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>s});var t=o(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);